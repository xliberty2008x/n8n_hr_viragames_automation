name: "Claude PR Action"
description: "Replies with Claude via Amazon Bedrock"
inputs:
  trigger_phrase:
    required: true
  timeout_minutes:
    required: false
    default: "60"
  github_token:
    required: true
  use_bedrock:
    required: true
  model:
    required: true
runs:
  using: "composite"
  steps:
    - name: Install dependencies
      shell: bash
      run: |
        # Install jq for JSON parsing
        sudo apt-get update -y
        sudo apt-get install -y jq curl unzip
        
        # Check if AWS CLI is already installed
        if ! command -v aws &> /dev/null; then
          echo "AWS CLI not found, installing..."
          curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          unzip -q awscliv2.zip
          sudo ./aws/install
          rm -rf awscliv2.zip aws/
        else
          echo "AWS CLI already installed"
        fi
        
        # Verify installation
        aws --version

    - name: Build Claude prompt
      id: prompt
      shell: bash
      run: |
        EVENT_FILE=$GITHUB_EVENT_PATH
        BODY=$(jq -r '.comment.body // .issue.body // ""' "$EVENT_FILE")
        echo "prompt<<EOF" >> $GITHUB_OUTPUT
        echo "$BODY" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Invoke Claude
      id: claude
      shell: bash
      env:
        MODEL_ID: ${{ inputs.model }}
      run: |
        # Prepare the prompt
        PROMPT="${{ steps.prompt.outputs.prompt }}"
        
        # Create request body for Claude 3
        REQUEST_BODY=$(jq -n \
          --arg prompt "$PROMPT" \
          '{
            "anthropic_version": "bedrock-2023-05-31",
            "max_tokens": 1024,
            "messages": [
              {
                "role": "user",
                "content": $prompt
              }
            ]
          }')
        
        # Save request body to file (AWS CLI needs file input for --body)
        echo "$REQUEST_BODY" > /tmp/request.json
        
        # Call Bedrock and save response
        aws bedrock-runtime invoke-model \
          --region $AWS_REGION \
          --model-id "$MODEL_ID" \
          --content-type application/json \
          --accept application/json \
          --body file:///tmp/request.json \
          /tmp/response.json
        
        # Extract the response text
        RESPONSE=$(cat /tmp/response.json | jq -r '.content[0].text // "No response from Claude"')
        
        # Clean up temp files
        rm -f /tmp/request.json /tmp/response.json
        
        # Set output
        echo "answer<<EOF" >> $GITHUB_OUTPUT
        echo "$RESPONSE" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Post reply
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
      run: |
        # Get the comment URL
        EVENT_FILE=$GITHUB_EVENT_PATH
        
        if [ "${{ github.event_name }}" == "issue_comment" ] || [ "${{ github.event_name }}" == "pull_request_review_comment" ]; then
          # For comments, use the comment HTML URL and construct the API endpoint
          COMMENT_ID=$(jq -r '.comment.id' "$EVENT_FILE")
          ISSUE_NUMBER=$(jq -r '.issue.number // .pull_request.number' "$EVENT_FILE")
          REPO="${{ github.repository }}"
          
          # Post reply
          gh api \
            --method POST \
            -H "Accept: application/vnd.github+json" \
            "/repos/$REPO/issues/$ISSUE_NUMBER/comments" \
            -f body="${{ steps.claude.outputs.answer }}"
        else
          # For new issues
          ISSUE_URL=$(jq -r '.issue.html_url' "$EVENT_FILE")
          ISSUE_NUMBER=$(jq -r '.issue.number' "$EVENT_FILE")
          REPO="${{ github.repository }}"
          
          gh api \
            --method POST \
            -H "Accept: application/vnd.github+json" \
            "/repos/$REPO/issues/$ISSUE_NUMBER/comments" \
            -f body="${{ steps.claude.outputs.answer }}"
        fi
